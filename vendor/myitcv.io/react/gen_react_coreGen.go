// Code generated by coreGen. DO NOT EDIT.

package react

import "github.com/gopherjs/gopherjs/js"

// AElem is the React element definition corresponding to the HTML <a> element
type AElem struct {
	Element
}

func (a *AElem) coreReactElement() {}

// AProps defines the properties for the <a> element
type AProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	Href                    string
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Target                  string
	Title                   string
}

// A creates a new instance of a <a> element with the provided props and
// children
func A(props *AProps, children ...Element) *AElem {
	type _AProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		Href                    string              `js:"href"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Target                  string              `js:"target"`
		Title                   string              `js:"title"`
	}

	rprops := &_AProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		rprops.Href = props.Href

		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Target = props.Target

		rprops.Title = props.Title
	}

	return &AElem{
		Element: createElement("a", rprops, children...),
	}
}

// AbbrElem is the React element definition corresponding to the HTML <abbr> element
type AbbrElem struct {
	Element
}

func (a *AbbrElem) coreReactElement() {}

// AbbrProps defines the properties for the <abbr> element
type AbbrProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Abbr creates a new instance of a <abbr> element with the provided props and
// children
func Abbr(props *AbbrProps, children ...Element) *AbbrElem {
	type _AbbrProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_AbbrProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &AbbrElem{
		Element: createElement("abbr", rprops, children...),
	}
}

// ArticleElem is the React element definition corresponding to the HTML <article> element
type ArticleElem struct {
	Element
}

func (a *ArticleElem) coreReactElement() {}

// ArticleProps defines the properties for the <article> element
type ArticleProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Article creates a new instance of a <article> element with the provided props and
// children
func Article(props *ArticleProps, children ...Element) *ArticleElem {
	type _ArticleProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_ArticleProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &ArticleElem{
		Element: createElement("article", rprops, children...),
	}
}

// AsideElem is the React element definition corresponding to the HTML <aside> element
type AsideElem struct {
	Element
}

func (a *AsideElem) coreReactElement() {}

// AsideProps defines the properties for the <aside> element
type AsideProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Aside creates a new instance of a <aside> element with the provided props and
// children
func Aside(props *AsideProps, children ...Element) *AsideElem {
	type _AsideProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_AsideProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &AsideElem{
		Element: createElement("aside", rprops, children...),
	}
}

// BElem is the React element definition corresponding to the HTML <b> element
type BElem struct {
	Element
}

func (a *BElem) coreReactElement() {}

// BProps defines the properties for the <b> element
type BProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// B creates a new instance of a <b> element with the provided props and
// children
func B(props *BProps, children ...Element) *BElem {
	type _BProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_BProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &BElem{
		Element: createElement("b", rprops, children...),
	}
}

// BrElem is the React element definition corresponding to the HTML <br> element
type BrElem struct {
	Element
}

func (a *BrElem) coreReactElement() {}

// BrProps defines the properties for the <br> element
type BrProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Br creates a new instance of a <br> element with the provided props and
// children
func Br(props *BrProps, children ...Element) *BrElem {
	type _BrProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_BrProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &BrElem{
		Element: createElement("br", rprops, children...),
	}
}

// ButtonElem is the React element definition corresponding to the HTML <button> element
type ButtonElem struct {
	Element
}

func (a *ButtonElem) coreReactElement() {}

// ButtonProps defines the properties for the <button> element
type ButtonProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Type                    string
}

// Button creates a new instance of a <button> element with the provided props and
// children
func Button(props *ButtonProps, children ...Element) *ButtonElem {
	type _ButtonProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Type                    string              `js:"type"`
	}

	rprops := &_ButtonProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Type = props.Type
	}

	return &ButtonElem{
		Element: createElement("button", rprops, children...),
	}
}

// CaptionElem is the React element definition corresponding to the HTML <caption> element
type CaptionElem struct {
	Element
}

func (a *CaptionElem) coreReactElement() {}

// CaptionProps defines the properties for the <caption> element
type CaptionProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Caption creates a new instance of a <caption> element with the provided props and
// children
func Caption(props *CaptionProps, children ...Element) *CaptionElem {
	type _CaptionProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_CaptionProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &CaptionElem{
		Element: createElement("caption", rprops, children...),
	}
}

// CodeElem is the React element definition corresponding to the HTML <code> element
type CodeElem struct {
	Element
}

func (a *CodeElem) coreReactElement() {}

// CodeProps defines the properties for the <code> element
type CodeProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Code creates a new instance of a <code> element with the provided props and
// children
func Code(props *CodeProps, children ...Element) *CodeElem {
	type _CodeProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_CodeProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &CodeElem{
		Element: createElement("code", rprops, children...),
	}
}

// DivElem is the React element definition corresponding to the HTML <div> element
type DivElem struct {
	Element
}

func (a *DivElem) coreReactElement() {}

// DivProps defines the properties for the <div> element
type DivProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Div creates a new instance of a <div> element with the provided props and
// children
func Div(props *DivProps, children ...Element) *DivElem {
	type _DivProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_DivProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &DivElem{
		Element: createElement("div", rprops, children...),
	}
}

// EmElem is the React element definition corresponding to the HTML <em> element
type EmElem struct {
	Element
}

func (a *EmElem) coreReactElement() {}

// EmProps defines the properties for the <em> element
type EmProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Em creates a new instance of a <em> element with the provided props and
// children
func Em(props *EmProps, children ...Element) *EmElem {
	type _EmProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_EmProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &EmElem{
		Element: createElement("em", rprops, children...),
	}
}

// FooterElem is the React element definition corresponding to the HTML <footer> element
type FooterElem struct {
	Element
}

func (a *FooterElem) coreReactElement() {}

// FooterProps defines the properties for the <footer> element
type FooterProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Footer creates a new instance of a <footer> element with the provided props and
// children
func Footer(props *FooterProps, children ...Element) *FooterElem {
	type _FooterProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_FooterProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &FooterElem{
		Element: createElement("footer", rprops, children...),
	}
}

// FormElem is the React element definition corresponding to the HTML <form> element
type FormElem struct {
	Element
}

func (a *FormElem) coreReactElement() {}

// FormProps defines the properties for the <form> element
type FormProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Form creates a new instance of a <form> element with the provided props and
// children
func Form(props *FormProps, children ...Element) *FormElem {
	type _FormProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_FormProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &FormElem{
		Element: createElement("form", rprops, children...),
	}
}

// H1Elem is the React element definition corresponding to the HTML <h1> element
type H1Elem struct {
	Element
}

func (a *H1Elem) coreReactElement() {}

// H1Props defines the properties for the <h1> element
type H1Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H1 creates a new instance of a <h1> element with the provided props and
// children
func H1(props *H1Props, children ...Element) *H1Elem {
	type _H1Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H1Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H1Elem{
		Element: createElement("h1", rprops, children...),
	}
}

// H2Elem is the React element definition corresponding to the HTML <h2> element
type H2Elem struct {
	Element
}

func (a *H2Elem) coreReactElement() {}

// H2Props defines the properties for the <h2> element
type H2Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H2 creates a new instance of a <h2> element with the provided props and
// children
func H2(props *H2Props, children ...Element) *H2Elem {
	type _H2Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H2Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H2Elem{
		Element: createElement("h2", rprops, children...),
	}
}

// H3Elem is the React element definition corresponding to the HTML <h3> element
type H3Elem struct {
	Element
}

func (a *H3Elem) coreReactElement() {}

// H3Props defines the properties for the <h3> element
type H3Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H3 creates a new instance of a <h3> element with the provided props and
// children
func H3(props *H3Props, children ...Element) *H3Elem {
	type _H3Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H3Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H3Elem{
		Element: createElement("h3", rprops, children...),
	}
}

// H4Elem is the React element definition corresponding to the HTML <h4> element
type H4Elem struct {
	Element
}

func (a *H4Elem) coreReactElement() {}

// H4Props defines the properties for the <h4> element
type H4Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H4 creates a new instance of a <h4> element with the provided props and
// children
func H4(props *H4Props, children ...Element) *H4Elem {
	type _H4Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H4Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H4Elem{
		Element: createElement("h4", rprops, children...),
	}
}

// H5Elem is the React element definition corresponding to the HTML <h5> element
type H5Elem struct {
	Element
}

func (a *H5Elem) coreReactElement() {}

// H5Props defines the properties for the <h5> element
type H5Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H5 creates a new instance of a <h5> element with the provided props and
// children
func H5(props *H5Props, children ...Element) *H5Elem {
	type _H5Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H5Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H5Elem{
		Element: createElement("h5", rprops, children...),
	}
}

// H6Elem is the React element definition corresponding to the HTML <h6> element
type H6Elem struct {
	Element
}

func (a *H6Elem) coreReactElement() {}

// H6Props defines the properties for the <h6> element
type H6Props struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// H6 creates a new instance of a <h6> element with the provided props and
// children
func H6(props *H6Props, children ...Element) *H6Elem {
	type _H6Props struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_H6Props{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &H6Elem{
		Element: createElement("h6", rprops, children...),
	}
}

// HeaderElem is the React element definition corresponding to the HTML <header> element
type HeaderElem struct {
	Element
}

func (a *HeaderElem) coreReactElement() {}

// HeaderProps defines the properties for the <header> element
type HeaderProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Header creates a new instance of a <header> element with the provided props and
// children
func Header(props *HeaderProps, children ...Element) *HeaderElem {
	type _HeaderProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_HeaderProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &HeaderElem{
		Element: createElement("header", rprops, children...),
	}
}

// HrElem is the React element definition corresponding to the HTML <hr> element
type HrElem struct {
	Element
}

func (a *HrElem) coreReactElement() {}

// HrProps defines the properties for the <hr> element
type HrProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Hr creates a new instance of a <hr> element with the provided props and
// children
func Hr(props *HrProps) *HrElem {
	type _HrProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_HrProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &HrElem{
		Element: createElement("hr", rprops),
	}
}

// IElem is the React element definition corresponding to the HTML <i> element
type IElem struct {
	Element
}

func (a *IElem) coreReactElement() {}

// IProps defines the properties for the <i> element
type IProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// I creates a new instance of a <i> element with the provided props and
// children
func I(props *IProps, children ...Element) *IElem {
	type _IProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_IProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &IElem{
		Element: createElement("i", rprops, children...),
	}
}

// IFrameElem is the React element definition corresponding to the HTML <iframe> element
type IFrameElem struct {
	Element
}

func (a *IFrameElem) coreReactElement() {}

// IFrameProps defines the properties for the <iframe> element
type IFrameProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	SrcDoc                  string
	Style                   *CSS
}

// IFrame creates a new instance of a <iframe> element with the provided props and
// children
func IFrame(props *IFrameProps, children ...Element) *IFrameElem {
	type _IFrameProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		SrcDoc                  string              `js:"srcDoc"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_IFrameProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		rprops.SrcDoc = props.SrcDoc

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &IFrameElem{
		Element: createElement("iframe", rprops, children...),
	}
}

// ImgElem is the React element definition corresponding to the HTML <img> element
type ImgElem struct {
	Element
}

func (a *ImgElem) coreReactElement() {}

// ImgProps defines the properties for the <img> element
type ImgProps struct {
	Alt                     string
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Src                     string
	Style                   *CSS
}

// Img creates a new instance of a <img> element with the provided props and
// children
func Img(props *ImgProps, children ...Element) *ImgElem {
	type _ImgProps struct {
		o                       *js.Object
		Alt                     string              `js:"alt"`
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Src                     string              `js:"src"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_ImgProps{
		o: object.New(),
	}

	if props != nil {
		rprops.Alt = props.Alt

		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		rprops.Src = props.Src

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &ImgElem{
		Element: createElement("img", rprops, children...),
	}
}

// InputElem is the React element definition corresponding to the HTML <input> element
type InputElem struct {
	Element
}

func (a *InputElem) coreReactElement() {}

// InputProps defines the properties for the <input> element
type InputProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Placeholder             string
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Type                    string
	Value                   string
}

// Input creates a new instance of a <input> element with the provided props and
// children
func Input(props *InputProps, children ...Element) *InputElem {
	type _InputProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Placeholder             string              `js:"placeholder"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Type                    string              `js:"type"`
		Value                   string              `js:"value"`
	}

	rprops := &_InputProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		rprops.Placeholder = props.Placeholder

		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Type = props.Type

		rprops.Value = props.Value
	}

	return &InputElem{
		Element: createElement("input", rprops, children...),
	}
}

// LabelElem is the React element definition corresponding to the HTML <label> element
type LabelElem struct {
	Element
}

func (a *LabelElem) coreReactElement() {}

// LabelProps defines the properties for the <label> element
type LabelProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	For                     string
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Label creates a new instance of a <label> element with the provided props and
// children
func Label(props *LabelProps, children ...Element) *LabelElem {
	type _LabelProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		For                     string              `js:"htmlFor"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_LabelProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		rprops.For = props.For

		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &LabelElem{
		Element: createElement("label", rprops, children...),
	}
}

// LiElem is the React element definition corresponding to the HTML <li> element
type LiElem struct {
	Element
}

func (a *LiElem) coreReactElement() {}

func (l *LiElem) RendersLi(*LiElem) {}

// LiProps defines the properties for the <li> element
type LiProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Li creates a new instance of a <li> element with the provided props and
// children
func Li(props *LiProps, children ...Element) *LiElem {
	type _LiProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_LiProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &LiElem{
		Element: createElement("li", rprops, children...),
	}
}

// MainElem is the React element definition corresponding to the HTML <main> element
type MainElem struct {
	Element
}

func (a *MainElem) coreReactElement() {}

// MainProps defines the properties for the <main> element
type MainProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Main creates a new instance of a <main> element with the provided props and
// children
func Main(props *MainProps, children ...Element) *MainElem {
	type _MainProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_MainProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &MainElem{
		Element: createElement("main", rprops, children...),
	}
}

// NavElem is the React element definition corresponding to the HTML <nav> element
type NavElem struct {
	Element
}

func (a *NavElem) coreReactElement() {}

// NavProps defines the properties for the <nav> element
type NavProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Nav creates a new instance of a <nav> element with the provided props and
// children
func Nav(props *NavProps, children ...Element) *NavElem {
	type _NavProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_NavProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &NavElem{
		Element: createElement("nav", rprops, children...),
	}
}

// OptionElem is the React element definition corresponding to the HTML <option> element
type OptionElem struct {
	Element
}

func (a *OptionElem) coreReactElement() {}

// OptionProps defines the properties for the <option> element
type OptionProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Value                   string
}

// Option creates a new instance of a <option> element with the provided props and
// children
func Option(props *OptionProps, children ...Element) *OptionElem {
	type _OptionProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Value                   string              `js:"value"`
	}

	rprops := &_OptionProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Value = props.Value
	}

	return &OptionElem{
		Element: createElement("option", rprops, children...),
	}
}

// PElem is the React element definition corresponding to the HTML <p> element
type PElem struct {
	Element
}

func (a *PElem) coreReactElement() {}

// PProps defines the properties for the <p> element
type PProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// P creates a new instance of a <p> element with the provided props and
// children
func P(props *PProps, children ...Element) *PElem {
	type _PProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_PProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &PElem{
		Element: createElement("p", rprops, children...),
	}
}

// PreElem is the React element definition corresponding to the HTML <pre> element
type PreElem struct {
	Element
}

func (a *PreElem) coreReactElement() {}

// PreProps defines the properties for the <pre> element
type PreProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Pre creates a new instance of a <pre> element with the provided props and
// children
func Pre(props *PreProps, children ...Element) *PreElem {
	type _PreProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_PreProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &PreElem{
		Element: createElement("pre", rprops, children...),
	}
}

// SelectElem is the React element definition corresponding to the HTML <select> element
type SelectElem struct {
	Element
}

func (a *SelectElem) coreReactElement() {}

// SelectProps defines the properties for the <select> element
type SelectProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Value                   string
}

// Select creates a new instance of a <select> element with the provided props and
// children
func Select(props *SelectProps, children ...*OptionElem) *SelectElem {
	type _SelectProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Value                   string              `js:"value"`
	}

	var elems []Element
	for _, v := range children {
		elems = append(elems, v)
	}

	rprops := &_SelectProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Value = props.Value
	}

	return &SelectElem{
		Element: createElement("select", rprops, elems...),
	}
}

// SpanElem is the React element definition corresponding to the HTML <span> element
type SpanElem struct {
	Element
}

func (a *SpanElem) coreReactElement() {}

// SpanProps defines the properties for the <span> element
type SpanProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Span creates a new instance of a <span> element with the provided props and
// children
func Span(props *SpanProps, children ...Element) *SpanElem {
	type _SpanProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_SpanProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &SpanElem{
		Element: createElement("span", rprops, children...),
	}
}

// StrikeElem is the React element definition corresponding to the HTML <s> element
type StrikeElem struct {
	Element
}

func (a *StrikeElem) coreReactElement() {}

// StrikeProps defines the properties for the <s> element
type StrikeProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Strike creates a new instance of a <s> element with the provided props and
// children
func Strike(props *StrikeProps, children ...Element) *StrikeElem {
	type _StrikeProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_StrikeProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &StrikeElem{
		Element: createElement("s", rprops, children...),
	}
}

// SupElem is the React element definition corresponding to the HTML <sup> element
type SupElem struct {
	Element
}

func (a *SupElem) coreReactElement() {}

// SupProps defines the properties for the <sup> element
type SupProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Sup creates a new instance of a <sup> element with the provided props and
// children
func Sup(props *SupProps, children ...Element) *SupElem {
	type _SupProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_SupProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &SupElem{
		Element: createElement("sup", rprops, children...),
	}
}

// TableElem is the React element definition corresponding to the HTML <table> element
type TableElem struct {
	Element
}

func (a *TableElem) coreReactElement() {}

// TableProps defines the properties for the <table> element
type TableProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Table creates a new instance of a <table> element with the provided props and
// children
func Table(props *TableProps, children ...Element) *TableElem {
	type _TableProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_TableProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &TableElem{
		Element: createElement("table", rprops, children...),
	}
}

// TbodyElem is the React element definition corresponding to the HTML <tbody> element
type TbodyElem struct {
	Element
}

func (a *TbodyElem) coreReactElement() {}

// TbodyProps defines the properties for the <tbody> element
type TbodyProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Tbody creates a new instance of a <tbody> element with the provided props and
// children
func Tbody(props *TbodyProps, children ...Element) *TbodyElem {
	type _TbodyProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_TbodyProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &TbodyElem{
		Element: createElement("tbody", rprops, children...),
	}
}

// TdElem is the React element definition corresponding to the HTML <td> element
type TdElem struct {
	Element
}

func (a *TdElem) coreReactElement() {}

// TdProps defines the properties for the <td> element
type TdProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Td creates a new instance of a <td> element with the provided props and
// children
func Td(props *TdProps, children ...Element) *TdElem {
	type _TdProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_TdProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &TdElem{
		Element: createElement("td", rprops, children...),
	}
}

// TextAreaElem is the React element definition corresponding to the HTML <textarea> element
type TextAreaElem struct {
	Element
}

func (a *TextAreaElem) coreReactElement() {}

// TextAreaProps defines the properties for the <textarea> element
type TextAreaProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Placeholder             string
	Ref                     Ref
	Role                    string
	Style                   *CSS
	Value                   string
}

// TextArea creates a new instance of a <textarea> element with the provided props and
// children
func TextArea(props *TextAreaProps, children ...Element) *TextAreaElem {
	type _TextAreaProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Placeholder             string              `js:"placeholder"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
		Value                   string              `js:"value"`
	}

	rprops := &_TextAreaProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		rprops.Placeholder = props.Placeholder

		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
		rprops.Value = props.Value
	}

	return &TextAreaElem{
		Element: createElement("textarea", rprops, children...),
	}
}

// ThElem is the React element definition corresponding to the HTML <th> element
type ThElem struct {
	Element
}

func (a *ThElem) coreReactElement() {}

// ThProps defines the properties for the <th> element
type ThProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Th creates a new instance of a <th> element with the provided props and
// children
func Th(props *ThProps, children ...Element) *ThElem {
	type _ThProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_ThProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &ThElem{
		Element: createElement("th", rprops, children...),
	}
}

// TheadElem is the React element definition corresponding to the HTML <thead> element
type TheadElem struct {
	Element
}

func (a *TheadElem) coreReactElement() {}

// TheadProps defines the properties for the <thead> element
type TheadProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Thead creates a new instance of a <thead> element with the provided props and
// children
func Thead(props *TheadProps, children ...Element) *TheadElem {
	type _TheadProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_TheadProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &TheadElem{
		Element: createElement("thead", rprops, children...),
	}
}

// TrElem is the React element definition corresponding to the HTML <tr> element
type TrElem struct {
	Element
}

func (a *TrElem) coreReactElement() {}

// TrProps defines the properties for the <tr> element
type TrProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Tr creates a new instance of a <tr> element with the provided props and
// children
func Tr(props *TrProps, children ...Element) *TrElem {
	type _TrProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	rprops := &_TrProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &TrElem{
		Element: createElement("tr", rprops, children...),
	}
}

// UlElem is the React element definition corresponding to the HTML <ul> element
type UlElem struct {
	Element
}

func (a *UlElem) coreReactElement() {}

// UlProps defines the properties for the <ul> element
type UlProps struct {
	AriaExpanded            bool
	AriaHasPopup            bool
	AriaLabelledBy          string
	ClassName               string
	DangerouslySetInnerHTML *DangerousInnerHTML
	DataSet                 DataSet
	ID                      string
	Key                     string
	OnChange                OnChange
	OnClick                 OnClick
	Ref                     Ref
	Role                    string
	Style                   *CSS
}

// Ul creates a new instance of a <ul> element with the provided props and
// children
func Ul(props *UlProps, children ...RendersLi) *UlElem {
	type _UlProps struct {
		o                       *js.Object
		AriaExpanded            bool                `js:"aria-expanded"`
		AriaHasPopup            bool                `js:"aria-haspopup"`
		AriaLabelledBy          string              `js:"aria-labelledby"`
		ClassName               string              `js:"className"`
		DangerouslySetInnerHTML *DangerousInnerHTML `js:"dangerouslySetInnerHTML"`
		ID                      string              `js:"id" react:"omitempty"`
		Key                     string              `js:"key" react:"omitempty"`
		OnChange                OnChange            `js:"onChange"`
		OnClick                 OnClick             `js:"onClick"`
		Ref                     Ref                 `js:"ref"`
		Role                    string              `js:"role"`
		Style                   *CSS                `js:"style"`
	}

	var elems []Element
	for _, v := range children {
		elems = append(elems, v)
	}

	rprops := &_UlProps{
		o: object.New(),
	}

	if props != nil {
		rprops.AriaExpanded = props.AriaExpanded

		rprops.AriaHasPopup = props.AriaHasPopup

		rprops.AriaLabelledBy = props.AriaLabelledBy

		rprops.ClassName = props.ClassName

		rprops.DangerouslySetInnerHTML = props.DangerouslySetInnerHTML

		if props.DataSet != nil {
			for dk, dv := range props.DataSet {
				rprops.o.Set("data-"+dk, dv)
			}
		}
		if props.ID != "" {
			rprops.ID = props.ID
		}
		if props.Key != "" {
			rprops.Key = props.Key
		}
		if props.OnChange != nil {
			rprops.o.Set("onChange", props.OnChange.OnChange)
		}
		if props.OnClick != nil {
			rprops.o.Set("onClick", props.OnClick.OnClick)
		}
		if props.Ref != nil {
			rprops.o.Set("ref", props.Ref.Ref)
		}
		rprops.Role = props.Role

		// TODO: until we have a resolution on
		// https://github.com/gopherjs/gopherjs/issues/236
		rprops.Style = props.Style.hack()
	}

	return &UlElem{
		Element: createElement("ul", rprops, elems...),
	}
}
